# Simple makefile to simulate and schematize a VHDL design.
#
# Giuseppe Calabrese
# 2022
# Public Domain

# Enabled VHDL source files. By default, all .vhd[l] sources are enabled.
# To enable only some sources, either rename them (e.g. 'x.vhd.no')
# or redefine this variable in $(CONFIG).
#
# This also gives the compilation order for the 'analyse' and 'elaborate' tasks.
SOURCES ?= $(shell find $(SOURCES_DIR) -name '*.vhd' -or -name '*.vhdl')

# Configuration file.
CONFIG ?= Config.makefile

include $(CONFIG)

# Check configuration.
ifndef TOP_UNIT
    $(error "Error: no top unit specified; edit $(CONFIG)")
endif

# Basic high-level tasks.

# The default task is to import & re-elaborate.
all: import make

# Check the syntax of every file.
check:
	$(GHDL) -s $(SOURCES)

# Import new/changed sources and figure out a meaningful compilation order.
import: $(WORK_DIR)
	$(GHDL) -i $(GHDL_OPTS) $(SOURCES)

# Re-analyse and re-elaborate what is needed according to the order inferred by
# the 'import' task.
make:
	$(GHDL) -m $(GHDL_OPTS) $(TOP_UNIT) $(TOP_ARCH)

# Simulate the elaborated design.
run: $(WAVES_DIR)
	$(GHDL) -r $(GHDL_OPTS) $(TOP_UNIT) $(TOP_ARCH) --wave=$(WAVES_DIR)/$(TOP_UNIT)$(ARCH_SPEC).ghw

# Run the test-bench.
test:
	TOP_UNIT=$(TEST_UNIT) TOP_ARCH=$(TEST_ARCH) make all run

# Produce a schematic of the design.
schematic: $(SCH_DIR)/$(TOP_UNIT).svg

# Produce a navigable source tree.
xref-html: $(HTML_DIR)
	$(GHDL) --xref-html -o $(HTML_DIR) $(GHDL_OPTS) $(SOURCES)

# Clean the stuff generated by GHDL.
clean:
	$(GHDL) --remove $(GHDL_OPTS)

# Clean everything generated.
purge: clean
	[ -d "$(WORK_DIR)" ]  && rm -rf "$(WORK_DIR)"  || true
	[ -d "$(WAVES_DIR)" ] && rm -rf "$(WAVES_DIR)" || true
	[ -d "$(SYNTH_DIR)" ] && rm -rf "$(SYNTH_DIR)" || true
	[ -d "$(SCH_DIR)" ]   && rm -rf "$(SCH_DIR)"   || true
	[ -d "$(HTML_DIR)" ]  && rm -rf "$(HTML_DIR)"  || true

# More low-level tasks.

# Analyse the sources in the order they're listed.
# You probably want to use the 'make' task instead. If not, make sure
# that sources are listed in the proper order; e.g. by listing them
# explicitly in $(CONFIG).
analyse:
	$(GHDL) -a $(GHDL_OPTS) $(SOURCES)

# Elaborate the design.
# This is only needed after 'analyse'.
elaborate:
	$(GHDL) -e $(GHDL_OPTS) $(TOP_UNIT) $(TOP_ARCH)

# Synthesize the design as Verilog.
verilog: $(SYNTH_DIR)/verilog/$(TOP_UNIT)$(ARCH_SPEC).v

.PHONY: all check import make run test schematic xref-html clean purge \
        analyse elaborate verilog

# Directories.
$(WORK_DIR):
	mkdir $@
$(WAVES_DIR):
	mkdir $@
$(SYNTH_DIR):
	mkdir $@
$(SYNTH_DIR)/verilog: $(SYNTH_DIR)
	mkdir $@
$(SCH_DIR):
	mkdir $@
$(HTML_DIR):
	mkdir $@

# Files.

# Not the only way to build it, of course.
$(WORK_DIR)/$(WORK)-obj$(STD).cf: import make
# Possible alternative.
# Requires that $(SOURCES) gives a proper compilation order.
#$(WORK_DIR)/$(WORK)-obj$(STD).cf: analyse elaborate

# Verilog synthesis artifact.
$(SYNTH_DIR)/verilog/$(TOP_UNIT)$(ARCH_SPEC).v: $(WORK_DIR)/$(WORK)-obj$(STD).cf $(SYNTH_DIR)/verilog
	$(GHDL) --synth $(GHDL_OPTS) --out=verilog $(SOURCES) -e $(TOP_UNIT) $(TOP_ARCH) > "$@"

# Yosyl's JSON synthesis artifact.
$(SCH_DIR)/$(TOP_UNIT).json: $(SYNTH_DIR)/verilog/$(TOP_UNIT).v $(SCH_DIR)
	$(YOSYS) -p "prep -top $(TOP_UNIT) $(YOSYS_PREP_OPTS); write_json $@" "$<"
	# $(YOSYS) -p "prep -top $(TOP_UNIT) $(YOSYS_PREP_OPTS); write_json $@" "$<"

# SVG schematic.
$(SCH_DIR)/$(TOP_UNIT)$(ARCH_SPEC).svg: $(SCH_DIR)/$(TOP_UNIT)$(ARCH_SPEC).json
	netlistsvg "$<" -o "$@"
